//=========================================================
// src/gcore_ctrl_main.c: generated by Hardware Configurator
//
// Low-level controller for gCore.  Provides the following functionality:
//   1. Power control
//     - Push Button soft power button with configurable short notification
//       to firmware for soft power control and other functionality with
//       long (5 second press) automatic shutdown
//     - Critical battery voltage warning and shutdown
//     - Wakeup control from RTC and charger (both start charge and end charge)
//   2. Real Time Clock with Alarm Wakeup and calibration correction
//   3. Battery charge monitor with LED status indicator
//   4. 4096 bytes of battery-backed NVRAM.  The first 1024 bytes may be
//      written to flash for preservation across battery connections.
//   5. USB voltage, USB input current, Battery voltage and Load current monitoring.
//   6. Chip temperature monitoring.
//   7. Backlight LED brightness control
//   8. MicroSD Card presence detection
//
// Firmware running on gCore's ESP32 communicates with this controller over a
// 100 kHz I2C interface.  The controller has the 7-bit I2C address 0x12. It
// appears as a series of 16-bit addressed 8- or 16-bit registers following 4096
// bytes of NVRAM.
//
// Uses an external precision 1.25V reference with an enable to it and the battery
// monitoring voltage circuit for battery level detection when powering up.
//
// TIMER0 - ADC Trigger
// TIMER2 - Tick Timer
// TIMER3 - SMBus ACK clear timer (bug work-around)
//
// Project modification notes
//   1. Delete routines from Interrupts.c every time you save from Configurator
//      as the actual routines are spread out over the code.
//   2. The project is built using the small memory model but this required
//      editing SILABS_STARTUP.A51 to set IDATALEN=0x100 and XDATALEN=0x1000
//      to initialize RAM at power-on.
//
//
// Copyright (c) 2021-2023 danjuliodesigns, LLC.  All rights reserved.
//
// This is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// It is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this software.  If not, see <https://www.gnu.org/licenses/>.
//
//=========================================================

//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8SB2_Register_Enums.h>
#include "config.h"
#include "gpio.h"
#include "led.h"
#include "nvram.h"
#include "InitDevice.h"
#include "rtc.h"
#include "run.h"
#include "smbus.h"
#include "watchdog.h"



//-----------------------------------------------------------------------------
// SiLabs_Startup() Routine
// ----------------------------------------------------------------------------
// This function is called immediately after reset, before the initialization
// code is run in SILABS_STARTUP.A51 (which runs before main() ). This is a
// useful place to disable the watchdog timer, which is enable by default
// and may trigger before main() in some instances.
//-----------------------------------------------------------------------------
void SiLabs_Startup (void)
{
	WD_Disable();
}


//-----------------------------------------------------------------------------
// main() Routine
// ----------------------------------------------------------------------------
int main (void)
{
	uint8_t startup_mask;

	// Power-on Initialization
	GPIO_Init();
	LED_Init();
	NVRAM_Init();
	RTC_Init();
	SMB_Init();

	// Sleep
	enter_SleepMode_from_RESET();

	while (1)
	{
		// Wakeup from RTC tick (RTC-only runtime ~8.4 uSec/tick)
		enter_ClockMode_from_SleepMode();

		// See if there are any conditions present to enter run mode
		startup_mask = 0;

		if (GPIO_BtnWakeupOccurred()) {
			startup_mask |= RUN_START_BTN;
		}
		if (GPIO_ChgWakeupOccurred()) {
			startup_mask |= RUN_START_CHG;
		}
		if (RTC_SawAlarm()) {
			startup_mask |= RUN_START_ALARM;
		}
		if (startup_mask != 0) {
			enter_RunMode_from_ClockMode();
			RUN_Task(startup_mask);
			enter_SleepMode_from_RunMode();
		} else {
			// Otherwise just go back to sleep
			enter_SleepMode_from_ClockMode();
		}
	}
}
